<div class="page-container">
    <div class="section-to-read">

        <ul>
            <li>
                <h2>
                    Use enableProdMode
                </h2>
                <p>
                    In dev mode, the Angular framework performs extra checks out-of-the-box for debugging purposes. It
                    also has change-detection mechanisms, so, when enabling production mode, we do not need this.
                </p>
            </li>
            <li>
                <h2>
                    Ahead-of-Time Compilation
                </h2>
                <p>
                    AOT is a very powerful compilation mode that the Angular team adopted for improving runtime
                    performance. It does so through tree-shaking and reducing the amount of computation required for
                    rendering an application, by performing computation at the build process.
                    The alternative compilation mode is JIT (Just In Time) which builds the bundle faster and renders
                    the application slower, so I highly recommended building using AOT to speed up the rendering process
                    of the application’s initialization.
                </p>
            </li>

            <li>
                <h2> Web Workers </h2>
                <p>
                    Web workers are like threading. As we all know, JS is single-threaded. Web workers partially remove
                    the limitation of JS being single-threaded because it makes JS run in browsers’ threads without
                    blocking the event loop and interrupting the main UI thread of browser.
                    Back to Angular with web workers. Change-detection in Angular needs to perform millions of checks
                    each second.
                    Due to the platform agnosticism of Angular and it being decoupled from the DOM architecture, it’s
                    possible to run our entire application (including change-detection) in a web worker and leave the
                    main UI thread only responsible for rendering.
                    So, change-detection mechanisms will run in the background of a browser in a separate thread.
                </p>
            </li>


            <li>
                <h2> Angular Universal and Server-Side Rendering </h2>
                <p>
                    A big challenge in any single-page application, not only in Angular, is that the whole application
                    cannot be rendered until the JS required for rendering is applicable, which leads to two problems:
                    Search engine optimization (SEO) does not work properly in these apps as they cannot index the
                    dynamic content of the application. (Template bindings such as content in ngModel={content}.)
                    Bad user experience as the user will have a blank page until the application is rendered.
                    Server-side rendering (SSR) solves this issue by pre-rendering the requested page on the server and
                    providing the markup of the rendered page during the initial page load.
                </p>
            </li>


            <li>
                <h2> Specifying Change-Detection Mechanisms </h2>
                <p> By default, Angular performs change detection over the entire component tree, which leads to heavy
                    computations in complex applications, especially when the computation is being done.
                    ChangeDetectionStrategy.OnPush
                    The OnPush change-detection strategy allows us to disable the change-detection mechanism for
                    sub-trees of the component tree.
                    By setting the change-detection strategy of any component to the value
                    ChangeDetectionStrategy.OnPush, we will make the change-detection perform only when the component
                    has received different inputs.
                    Angular will consider inputs as different when it compares them with the previous inputs for
                    reference and the result of the reference check is false. It is performed using immutable data
                    structures.
                    If you come from a React background, it is like PureComponents. Or, like implementing
                    shouldComponentUpdate() with specific criteria.
                </p>
            </li>



            <li>
                <h2> Caching Lookups and Configurations </h2>
                <p> One of the most powerful features of observables is that you can cache an HTTP request, and, as we
                    know, the default HTTP request of Angular does not return observables.
                    It will be very effective if you have lots of configurations and lookups across the application.
                    Caching in observables is achi
                </p>
            </li>



            <li>
                <h2> Using Pure Pipes (Caching Filtered Values) </h2>
                <p> The pure flag indicates that the pipe is not dependent on any global state and does not produce
                    side-effects.
                    This means that the pipe will return the same output when invoked with the same input. This way,
                    Angular can cache the outputs for all the input parameters that the pipe has been invoked with, and
                    reuse them to not have to recompute them on each evaluation.</p>
            </li>



            <li>
                <h2>Using trackBy Option for *ngFor Directive </h2>
                <p> </p>
            </li>




        </ul>

        <app-references [references]="references"></app-references>
    </div>
</div>